# ë¬¸ì œ ì´ë¦„ (BOJ 1325 íš¨ìœ¨ì ì¸ í•´í‚¹)

## âŒ ë‚´ê°€ í‹€ë¦° ì´ìœ 
- DFSë¥¼ ì‚¬ìš©í•´ì„œ ê° ì»´í“¨í„°ì—ì„œ í•´í‚¹ ê°€ëŠ¥í•œ ìˆ˜ë¥¼ ì„¸ëŠ” ë°©ì‹ì€ ë§ì•˜ì§€ë§Œ, Python3ë¡œ ì œì¶œí•´ ì‹œê°„ ì´ˆê³¼ê°€ ë°œìƒí–ˆìŒ.
- ë©”ëª¨ì´ì œì´ì…˜ì„ ì‹œë„í–ˆì§€ë§Œ, `visited` ë°°ì—´ê³¼ì˜ ì¶©ëŒë¡œ ì¸í•´ ì˜¤íˆë ¤ ì •ë‹µì„ í‹€ë¦¬ê²Œ ë§Œë“¤ê¸°ë„ í–ˆìŒ.
- DFS ì¬ê·€ í˜¸ì¶œ ê¹Šì´ ë¬¸ì œë¡œ `RecursionError` ê°€ëŠ¥ì„±ë„ ìˆì—ˆìŒ.

## âœ… ì˜¬ë°”ë¥¸ ì ‘ê·¼
- **ë¬¸ì œë¥¼ ì—­ë°©í–¥ ê·¸ë˜í”„ë¡œ í•´ì„**: Aê°€ Bë¥¼ ì‹ ë¢°í•œë‹¤ëŠ” ê²ƒì€ `B â†’ A` ê°„ì„ ì„ ë§Œë“ ë‹¤ëŠ” ì˜ë¯¸. ì¦‰, Bë¥¼ í•´í‚¹í•˜ë©´ Aë„ í•´í‚¹í•  ìˆ˜ ìˆë‹¤ëŠ” ëœ».
- ê° ì •ì ì„ ì‹œì‘ì ìœ¼ë¡œ DFS í˜¹ì€ BFSë¥¼ ìˆ˜í–‰í•˜ì—¬ ë„ë‹¬ ê°€ëŠ¥í•œ ë…¸ë“œ ìˆ˜ë¥¼ ê³„ì‚°í•´ì•¼ í•¨.
- ëª¨ë“  ì •ì ì— ëŒ€í•´ í•´í‚¹ ê°€ëŠ¥í•œ ì»´í“¨í„° ìˆ˜ë¥¼ êµ¬í•˜ê³ , ê·¸ ì¤‘ ìµœëŒ€ê°’ì„ ê°€ì§€ëŠ” ì •ì ì„ ì¶œë ¥.
- Python3 ëŒ€ì‹  PyPy3ë¡œ ì œì¶œí•˜ì—¬ ì‹œê°„ ì´ˆê³¼ í•´ê²°.

## ğŸ’¡ í•µì‹¬ ê°œë…
- ë°©í–¥ ê·¸ë˜í”„
- DFS (ë˜ëŠ” BFS)
- ê·¸ë˜í”„ ì—­ë°©í–¥ ê°„ì„  êµ¬ì„±
- PyPy3 (Python3ì˜ ì„±ëŠ¥ í•œê³„ ë³´ì™„)

## ğŸ“ ì½”ë“œ ë¹„êµ

### âŒ ë‚´ ì½”ë“œ (í‹€ë¦° ì½”ë“œ - Python3ì—ì„œ ì‹œê°„ì´ˆê³¼ ë°œìƒ)
```python
import sys
from collections import defaultdict

sys.setrecursionlimit(100_000)

def dfs(v):
    visited[v] = True
    count = 1
    for node in graph[v]:
        if not visited[node]:
            count += dfs(node)
    return count

n, m = map(int, sys.stdin.readline().split())
graph = defaultdict(list)

for _ in range(m):
    a, b = map(int, sys.stdin.readline().split())
    graph[b].append(a)

max_count = 0
result = []

for i in range(1, n + 1):
    visited = [False] * (n + 1)
    cnt = dfs(i)
    if cnt > max_count:
        max_count = cnt
        result = [i]
    elif cnt == max_count:
        result.append(i)

print(' '.join(map(str, sorted(result))))
```

### âœ… ì •ë‹µ ì½”ë“œ (PyPy3ì—ì„œ í†µê³¼)
```python
import sys
from collections import defaultdict, deque
sys.setrecursionlimit(100_000)

def bfs(start):
    visited = [False] * (n + 1)
    visited[start] = True
    queue = deque([start])
    count = 1
    while queue:
        cur = queue.popleft()
        for next in graph[cur]:
            if not visited[next]:
                visited[next] = True
                queue.append(next)
                count += 1
    return count

n, m = map(int, sys.stdin.readline().split())
graph = defaultdict(list)

for _ in range(m):
    a, b = map(int, sys.stdin.readline().split())
    graph[b].append(a)

max_count = 0
result = []

for i in range(1, n + 1):
    cnt = bfs(i)
    if cnt > max_count:
        max_count = cnt
        result = [i]
    elif cnt == max_count:
        result.append(i)

print(' '.join(map(str, sorted(result))))
```

## ğŸ”„ ë³µìŠµ í•„ìš” ì—¬ë¶€
- [x] ë‹¤ì‹œ í’€ì–´ë´ì•¼ í•¨  
- [x] ê°œë… ë³µìŠµ í•„ìš”  
  - ì—­ë°©í–¥ ê·¸ë˜í”„ êµ¬ì„±
  - BFSì™€ DFSì˜ ì‹œê°„ ì°¨ì´
  - PyPy3 í™œìš© íƒ€ì´ë°