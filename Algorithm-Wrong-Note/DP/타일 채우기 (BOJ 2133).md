# 타일 채우기 (BOJ 2133)

## ❌ 내가 틀린 이유
- `N=4`인 경우까지 직접 손으로 구했을 때, 모든 경우를 고려하지 못하고 잘못된 패턴을 도출함.
- 점화식을 `d[i] = 3 * d[i-2]`로 설정했으나, 추가적인 경우의 수를 고려하지 않아 틀린 결과가 나옴.
- `N`이 커질수록 규칙을 정확히 분석하지 못해 `N이 1~10` 까지의 테스트 케이스를 보고 `d[i] = 3 * d[i-2] + (d[i-4] - d[i-2])`의 점화식 도출
-  해당 점화식으로 N == 30 까지는 문제 없었음. 그러나 GPT에서 올바른 점화식을 알려줌

## ✅ 올바른 접근
- `N=2, 4, 6, ...`인 경우의 패턴을 찾아 **점화식**을 올바르게 설정해야 함.
- `N`이 홀수일 경우 채울 수 없으므로 `0`을 반환.
- `N`이 짝수일 경우, `d[i]`는 `3 * d[i-2]`뿐만 아니라 `d[i-4]`, `d[i-6]`, ... 등 **모든 이전 짝수 크기의 패턴**을 고려해야 함.
- 점화식:  
  \[
  d[i] = 3 \times d[i-2] + 2 \times d[i-4] + 2 \times d[i-6] + \dots + 2 \times d[0]
  \]

## 💡 핵심 개념
- **동적 계획법 (DP)**: 이전 결과를 이용해 현재 값을 계산
- **점화식 찾기**: 작은 값부터 규칙을 찾아 일반화
- **짝수 `N`만 가능**: `N`이 홀수일 경우 `0`

## 📝 코드 비교
### ❌ 내 코드 (틀린 코드)
```python
import sys

def solution():
    n = int(sys.stdin.readline().rstrip())
    
    if n == 1: return print(0)
    
    d = [0] * (n+1)
    d[0] = 1
    d[2] = 3
    
    for i in range(4, n+1, 2):
        d[i] = 3 * d[i-2] + (d[i-2] - d[i-4])
        
    print(d[n])

if __name__ == "__main__":
    solution()
```

### ✅ 정답 코드 (올바른 코드)
```python
import sys

def solution():
    n = int(sys.stdin.readline().strip())
    if n % 2 == 1:
        print(0)
        return
    
    d = [0] * (n + 1)
    d[0] = 1  # 계산 편의를 위해 d[0]을 1로 설정
    d[2] = 3
    
    for i in range(4, n + 1, 2):
        d[i] = 3 * d[i - 2]
        for j in range(i - 4, -1, -2):
            d[i] += 2 * d[j]
    
    print(d[n])

if __name__ == "__main__":
    solution()
```

## 🔄 복습 필요 여부
- [x] 다시 풀어봐야 함  
- [x] 개념 복습 필요

