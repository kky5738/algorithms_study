# 계단 수 (BOJ 10844)

## ❌ 내가 틀린 이유
- 계단 수 문제를 보고 DP로 접근해야 한다는 것을 떠올리지 못함.
- 점화식을 직접 도출하지 못하고, 어떻게 상태를 정의해야 할지 막막했음.
- 해결 방법을 듣고 나서야 점화식과 DP 배열을 활용하는 방식을 이해할 수 있었음.

## ✅ 올바른 접근
1. **DP 상태 정의**
   - `dp[i][j]`: 길이가 `i`이고 마지막 숫자가 `j`인 계단 수의 개수
2. **점화식 세우기**
   - `dp[i][0] = dp[i-1][1]`
   - `dp[i][9] = dp[i-1][8]`
   - `dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]` (1 ≤ j ≤ 8)
3. **초기값 설정**
   - `dp[1][1] ~ dp[1][9]` = 1 (길이가 1인 계단 수는 자기 자신만 가능)
   - `dp[1][0] = 0` (0으로 시작하는 수는 계단수가 아님)
4. **모듈러 연산 적용**
   - 숫자가 커지므로 모든 연산에 `% 1,000,000,000` 적용

## 💡 핵심 개념
- **동적 계획법(DP)**: 작은 문제를 해결하며 큰 문제를 해결하는 방식
- **점화식 도출**: 상태를 정의하고, 이전 상태에서 현재 상태를 만드는 규칙 찾기
- **모듈러 연산 최적화**: 큰 수 연산을 방지하기 위해 연산마다 `% 1000000000` 적용

## 📝 코드 비교
### ❌ 내 코드 (점화식을 떠올리지 못한 경우)
```python
# 아무것도 떠올리지 못함
```

### ✅ 정답 코드 (올바른 DP 풀이)
```python
def solution():
    n = int(input())

    d = [[0] * 10 for _ in range(n + 1)]

    for j in range(1, 10):
        d[1][j] = 1

    for i in range(2, n + 1):
        d[i][0] = d[i-1][1] % 1000000000
        d[i][9] = d[i-1][8] % 1000000000
        for j in range(1, 9):
            d[i][j] = (d[i-1][j-1] + d[i-1][j+1]) % 1000000000

    print(sum(d[n]) % 1000000000)
```

## 🔄 복습 필요 여부
- [x] 다시 풀어봐야 함  
- [x] 개념 복습 필요  

