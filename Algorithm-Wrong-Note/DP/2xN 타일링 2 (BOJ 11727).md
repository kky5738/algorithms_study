# 2×n 타일링 2 (BOJ 11727)

## ❌ 내가 틀린 이유
- 점화식을 정확히 도출하지 못하고, 1~12까지의 출력값을 보고 `d[i] = 2*d[i-1] + arr[i % 2]` 형태로 유추함.
- 하지만 `arr[i % 2]`로 보정하는 방식은 불필요하며, 정확한 점화식을 찾지 못했음.

## ✅ 올바른 접근
- `d[i]`: 2×i 크기의 직사각형을 채우는 방법의 수를 나타냄.
- 점화식: `d[i] = d[i-1] + 2 * d[i-2]`
  - `2×(i-1)` 타일에 `1×2` 타일 하나를 추가하는 경우 (`d[i-1]`)
  - `2×(i-2)` 타일에 `2×1` 타일 2개 또는 `2×2` 타일을 추가하는 경우 (`2 * d[i-2]`)
- 초기값 설정:
  - `d[1] = 1` (직사각형을 1×2 타일 하나로 채우는 방법 1개)
  - `d[2] = 3` (2×1 타일 2개, 2×2 타일 1개, 1×2 타일 2개를 놓는 방법)
- 모듈러 연산 적용: 숫자가 커지므로 `% 10007`을 연산마다 적용하여 오버플로우 방지

## 💡 핵심 개념
- **동적 계획법(DP)**: 이전 상태를 이용하여 현재 상태를 구하는 방식
- **점화식 도출**: 문제의 패턴을 분석하여 점화식을 세우는 과정
- **모듈러 연산 최적화**: 연산 중 큰 수 처리를 위해 `% 10007` 적용

## 📝 코드 비교
### ❌ 내 코드 (틀린 코드)
```python
import sys

n = int(sys.stdin.readline().rstrip())

d = [0] * (n + 1)
d[1] = 1
arr = [1, -1]

for i in range(2, n+1):
    d[i] = (2*d[i-1] + arr[i % 2]) % 10007

print(d[n] % 10007)
```

### ✅ 정답 코드 (올바른 코드)
```python
def solution():
    import sys
    input = sys.stdin.read
    n = int(input().strip())

    if n == 1:
        print(1)
        return
    elif n == 2:
        print(3)
        return

    prev2, prev1 = 1, 3  # d[1] = 1, d[2] = 3

    for _ in range(3, n + 1):
        current = (prev1 + 2 * prev2) % 10007
        prev2, prev1 = prev1, current

    print(prev1)

solution()
```

## 🔄 복습 필요 여부
- [ ] 다시 풀어봐야 함  
- [ ] 개념 복습 필요  

